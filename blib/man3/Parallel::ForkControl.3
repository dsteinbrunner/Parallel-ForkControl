.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parallel::ForkControl 3"
.TH Parallel::ForkControl 3 "2011-06-15" "perl v5.12.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parallel::ForkControl \- Finer grained control of processes on a Unix System
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&  use Parallel::ForkControl;
\&  my $forker = new Parallel::ForkControl(
\&                                WatchCount              => 1,
\&                                MaxKids                 => 50,
\&                                MinKids                 => 5,
\&                                WatchLoad               => 1,
\&                                MaxLoad                 => 8.00,
\&                                Name                    => \*(AqMy Forker\*(Aq,
\&                                Code                    => \e&mysub
\&        );
\&  my @hosts = qw/host1 host2 host3 host5 host5/;
\&
\&  my $altSub = sub { my $t = shift; ... };
\&
\&  foreach my $host (@hosts) {
\&        if( $host eq \*(AqalternateHost\*(Aq ) {
\&                $forker\->run( $altSub, $host );
\&        }
\&        else {
\&                $forker\->run($host);
\&        }
\&  }
\&
\&  $forker\->cleanup();  # wait for all children to finish;
\&  .....
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parallel::ForkControl introduces a new and simple way to deal with \fIfork()\fRing.
The 'Code' parameter will be run everytime the \fIrun()\fR method is called on the
fork object.  Any parameters passed to the \fIrun()\fR method will be passed to the
subroutine ref defined as the 'Code' arg.  This allows a developer to spend
less time worrying about the underlying \fIfork()\fR system, and just write code.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew([ Option => Value ... ])\fR" 4
.IX Item "new([ Option => Value ... ])"
Constructor.  Creates a Parallel::ForkControl object for using.  Ideally,
all options should be set here and not changed, though the accessors and
mutators allow such behavior, even while the \fB\f(BIrun()\fB\fR method is being executed.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "Name" 4
.IX Item "Name"
.PD
Process Name that will show up in a 'ps', mostly cosmetic, but serves as an
easy way to distinguish children and parent in a ps.
.IP "ProcessTimeOut" 4
.IX Item "ProcessTimeOut"
The max time any given process is allowed to run before its interrupted.
\&\fBDefault :\fR120 seconds
.IP "WatchCount" 4
.IX Item "WatchCount"
Enforce count (MaxKids) restraints on new processes.
\&\fBDefault :\fR 1
.IP "WatchLoad" 4
.IX Item "WatchLoad"
Enforce load based (MaxLoad) restraints on process creation. \s-1NOTE:\s0 This \s-1MUST\s0 be
a true value to enable throttling based on Load Averages.
\&\fBDefault :\fR 0
.IP "WatchMem ***" 4
.IX Item "WatchMem ***"
(unimplemented)
.IP "WatchCPU ***" 4
.IX Item "WatchCPU ***"
(unimplemented)
.IP "Method" 4
.IX Item "Method"
May be 'block' or 'cycle'.  Block will fork off MaxKids and wait for all of them
to die, then fork off MaxKids more processes.  Cycle will continually replace
processes as the restraints allow.  Cycle is almost \s-1ALWAYS\s0 the preferred method.
\&\fBDefault :\fRCycle
B
.IP "MaxKids" 4
.IX Item "MaxKids"
The maximum number of children that may be running at any given time.
\&\fBDefault :\fR 5
.IP "MinKids" 4
.IX Item "MinKids"
The minimum number of kids to keep running regardless of load/memory/CPU
throttling.
\&\fBDefault :\fR 1
.IP "MaxLoad" 4
.IX Item "MaxLoad"
The maximum one minute average load.  Make sure to set WatchLoad.
\&\fBDefault :\fR 4.50 (off by default)
.IP "MaxMem  ***" 4
.IX Item "MaxMem  ***"
(unimplemented)
.IP "MaxCPU ***" 4
.IX Item "MaxCPU ***"
(unimplemented)
.IP "Code" 4
.IX Item "Code"
This should be a subroutine reference.  If you intend on passing arguments to this
subroutine arguments it is imperative that you \fB\s-1NOT\s0\fR include () in the reference.
All code inside the subroutine will be run in the child process.  The module provides
all the necessary checks and safety nets, so your subroutine may just \*(L"return\*(R".  It is
not necessary, nor is it good practice to have \fIexit()\fRs in this subroutine as eventually,
return codes are stored and made available to the parent process after completion.
Examples:
.Sp
.Vb 5
\&        my $code = sub {
\&                        # do something useful
\&                        my $t = shift;
\&                        return $t;
\&        };
\&
\&        my $forker = new Parallel::ForkControl(
\&                                Name => \*(Aqme\*(Aq,
\&                                MaxKids => 10,
\&                                Code => $code
\&                                # or
\&                                #Code => \e&mysub
\&        )
\&
\&        sub mysub {
\&                my $t = shift;
\&                return $t;
\&        }
.Ve
.Sp
Alternatively, you may pass the sub reference as the first argument of the \fB\f(BIrun()\fB\fR method.
.IP "Accounting" 4
.IX Item "Accounting"
By default this is turned off.  If you would like to keep track of the exit codes, sub routine
return values, and current status of the children forked by the \fB\f(BIrun()\fB\fR routine, enable this
option:
.Sp
.Vb 1
\&        Accounting      => 1
.Ve
.IP "TrackArgs" 4
.IX Item "TrackArgs"
By setting this to a true value, the fork controller will keep track of the arguments
passed to each of the children.  Using this you can see what arguments yielded which results.
This argument truly only makes sense if you've enabled the Accounting option.
.IP "Check_At" 4
.IX Item "Check_At"
This determines between how many child processes the module does some checking
to verify the validity of its internal process table.  It shouldn't be necessary 
to modify this value, but given it is a little low, someone only utilizing this
module for a larger number of data sets might want to check things at larger
intervals.
\&\fBDefault :\fR 2
.IP "Debug" 4
.IX Item "Debug"
A number 0\-4. The higher the number, the more debugging information you'll see.
0 means nothing.
\&\fBDefault :\fR 0
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .IP "\fBrun([ \fB@ARGS\fB ])\fR" 4
.el .IP "\fBrun([ \f(CB@ARGS\fB ])\fR" 4
.IX Item "run([ @ARGS ])"
This method calls the subroutine passed as the \fICode\fR option.  This method
handles process throttling, creation, monitoring, and reaping.  The subroutine
in the \fICode\fR option run in the child process and all control is returned to the
parent object as soon as the child is successfully created. \fB\f(BIrun()\fB\fR will block
until it is allowed to create a process or process creation fails completely.
\&\fB\f(BIrun()\fB\fR returns the \s-1PID\s0 of the child on success, or undef on failure.  \fB\s-1NOTE:\s0\fR This
is not the return code of your subroutine.  I will eventually provide mapping
to argument sets passed to \fIrun()\fR with success/failure options and (idea) a
\&\*(L"Report\*(R" option to enable some form of reporting based on that \s-1API\s0.
.IP "\fB\f(BIcleanup()\fB\fR" 4
.IX Item "cleanup()"
This method blocks until all children have finished processing.
.IP "\fB\f(BIkids()\fB\fR" 4
.IX Item "kids()"
This method returns the PIDs of all the children still alive in array context.
In scalar context it returns the number of children still running.
.ie n .IP "\fBkid_time( \fB$PID\fB )\fR" 4
.el .IP "\fBkid_time( \f(CB$PID\fB )\fR" 4
.IX Item "kid_time( $PID )"
This method returns the start time in epoch seconds that the \s-1PID\s0 began.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
.IP "01/08/2004 \- brad@divisionbyzero.net" 4
.IX Item "01/08/2004 - brad@divisionbyzero.net"
For some reason, I'm having to throttle process creation, as a slew of  processes
starting and ending at the same time seems to be causing problems on my machine.
I've adjust the Check_At down to 2 which seems to catch any processes whose SIG{\s-1CHLD\s0}
gets lost in the mess of spawning.  I'm looking into a more permanent, professional
solution.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perldoc \-f fork, search \s-1CPAN\s0 for Parallel::ForkManager
.SH "AUTHOR"
.IX Header "AUTHOR"
Brad Lhotsky <brad@divisionbyzero.net>
.SH "CONTRIBUTIONS BY"
.IX Header "CONTRIBUTIONS BY"
Mark Thomas <mark@ackers.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003 by Brad Lhotsky
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
